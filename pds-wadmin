#!/bin/bash
#
# W Social PDS Admin Tool
# Unified W admin script for W ID, Account Transfer, and Invitation management
#
# Usage: pds-wadmin <category> <command> [args...]
#        pds-wadmin-dev <category> <command> [args...]
#        pds-wadmin-stage <category> <command> [args...]
#        pds-wadmin-prod <category> <command> [args...]
#
# When called as 'pds-wadmin', requires environment variables:
#   PDS_HOST - The PDS hostname (e.g., https://pds-stage.wsocial.dev)
#   PDS_ADMIN_PASSWORD - Admin password for authentication
#
# When called via symlinks (pds-wadmin-dev, pds-wadmin-stage, pds-wadmin-prod),
# automatically fetches credentials from Vault based on the environment name.
#

set -euo pipefail

# Check required environment variables
check_env() {

  # Extract the tail-end of the name of the script, e.g. "pds-wadmin-dev" -> "dev"
  SCRIPT_NAME="$(basename "$0")"
  ENV="${SCRIPT_NAME##*-}"

  # If ENV equals SCRIPT_NAME, there's no suffix (called as 'pds-wadmin')
  if [ "$ENV" = "wadmin" ]; then
    ENV=""

    if [ -z "${PDS_HOST:-}" ]; then
      echo "ERROR: PDS_HOST environment variable is not set"
      echo "Example: export PDS_HOST=https://pds-stage.wsocial.dev"
      exit 1
    fi

    if [ -z "${PDS_ADMIN_PASSWORD:-}" ]; then
      echo "ERROR: PDS_ADMIN_PASSWORD environment variable is not set"
      echo "Example: export PDS_ADMIN_PASSWORD=your-admin-password"
      exit 1
    fi
    echo "Using ${PDS_HOST}"
  else
    # Called via symlink (dev/stage/prod) - fetch from vault
    PDS_ENV="pds/${ENV}"
    echo "Using ${PDS_ENV}"

    # Login to vault, if needed
    export VAULT_ADDR=https://vault.wsocial.cloud
    vault token lookup >/dev/null 2>&1 || vault login -method=github -path=github

    # Set up env vars from vault
    export PDS_ADMIN_PASSWORD="$(vault kv get -mount=secret -field ADMIN_PASSWORD $PDS_ENV)"
    export PDS_HOST="https://$(vault kv get -mount=secret -field HOSTNAME $PDS_ENV)"
  fi
}

# Check and ensure Nomad authentication
check_nomad_auth() {
  if [ -z "$ENV" ]; then
    echo "ERROR: Nomad commands require environment context (use pds-wadmin-dev, pds-wadmin-stage, or pds-wadmin-prod)"
    exit 1
  fi

  # Nomad cluster address — always the same regardless of PDS env
  export NOMAD_ADDR="https://nomad.wsocial.cloud"

  # Export nomad token from cache if it exists
  local token_cache="$HOME/.nomad-token"
  if [ -f "$token_cache" ]; then
    export NOMAD_TOKEN="$(cat "$token_cache")"
  fi

  # Check if authentication works, login if needed
  if ! nomad status -token="${NOMAD_TOKEN:-}" >/dev/null 2>&1; then
    echo "Nomad authentication required..."
    local login_output
    login_output=$(nomad login -method=vault-oidc 2>&1)
    echo "$login_output"

    # Extract Secret ID from output
    local secret_id
    secret_id=$(echo "$login_output" | grep "^Secret ID" | awk '{print $4}')

    if [ -z "$secret_id" ]; then
      echo "ERROR: Failed to extract token from nomad login output"
      exit 1
    fi

    # Set and cache the token
    export NOMAD_TOKEN="$secret_id"
    echo "$NOMAD_TOKEN" > "$token_cache"
    chmod 600 "$token_cache"
  fi
}

# Print usage information
usage() {
  cat <<EOF
W Social PDS Admin Tool

Unified admin interface for PDS management.

Usage: $0 <category> <command> [args...]

Categories:
  wid           W ID (Legal ID) management
  transfer      Account transfers (rehoming within cluster, import/export)
  invitation    Invitation management
  nomad         Nomad job management and logs
  goat          Goat admin tool (wrapper with auto-configured env vars)

WID Commands:
  wid list                           List all accounts with W ID links
  wid show <did>                     Show W ID details for account
  wid update <did> <legal-id>        Update W ID for account
  wid handle <did> <new-handle>      Update account handle (admin override, bypasses user)
  wid db [--query=SQL]               Query neuro_identity_link table directly via sqlite3
                                     Default: show all rows with duplicates highlighted
                                     Use --query=SQL to run a custom query

Transfer Commands:
  transfer rehome <did> <target-pds-url> [handle]
                                     Rehome account to another PDS in cluster

Invitation Commands:
  invitation create <email> [--handle=HANDLE]
                                     Create new invitation (unblock zombie accounts)
  invitation list [--status=STATUS] [--before=TIMESTAMP] [--json]
                                     List invitations
  invitation stats [--since=TIMESTAMP] [--json]
                                     Get invitation statistics
  invitation show <email|id>         Show specific invitation
  invitation revoke <email|id>       Revoke pending invitation
  invitation purge --status=STATUS [--before=TIMESTAMP]
                                     Purge invitations by status

Invitation Status Values:
  pending, consumed, expired, revoked, all

Nomad Commands:
  nomad status                       Show Nomad job status
  nomad logs [--tail=N] [--follow]   Show logs from running allocation

Goat Commands:
  goat <command> [args...]           Run goat admin tool with auto-configured credentials
                                     (passes all arguments through to goat)

Environment Variables (only when called as 'pds-wadmin'):
  PDS_HOST                  PDS hostname (e.g., https://pds-stage.wsocial.dev)
  PDS_ADMIN_PASSWORD        Admin password

Examples:
  # WID management
  $0 wid list
  $0 wid show did:plc:abc123
  $0 wid update did:plc:abc123 uuid@legal.lab.tagroot.io
  $0 wid handle did:plc:abc123 ingmar.wsocial.eu

  # Account transfer (rehoming)
  $0 transfer rehome did:plc:abc123 https://pds2.wsocial.dev

  # Invitation management
  $0 invitation create user@example.com
  $0 invitation create user@example.com --handle=john_doe
  $0 invitation list --status=pending
  $0 invitation stats --since=2026-02-01T00:00:00Z
  # Nomad management (requires env context: -dev, -stage, or -prod)
  pds-wadmin-dev nomad status
  pds-wadmin-dev nomad logs --tail=100
  pds-wadmin-stage nomad logs --follow

  # Goat admin tool (with auto-configured credentials)
  pds-wadmin-dev goat account list
  pds-wadmin-stage goat repo describe did:plc:abc123

  $0 invitation show user@example.com
  $0 invitation revoke user@example.com
  $0 invitation purge --status=consumed --before=2026-01-01T00:00:00Z

EOF
  exit 1
}

# Make API call to PDS
api_call() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"

  local url="${PDS_HOST}/xrpc/${endpoint}"

  if [ "$method" = "GET" ]; then
    curl -s --user "admin:${PDS_ADMIN_PASSWORD}" \
      "$url" 2>&1
  else
    curl -s --user "admin:${PDS_ADMIN_PASSWORD}" \
      -X "$method" \
      -H "Content-Type: application/json" \
      -d "$data" \
      "$url" 2>&1
  fi
}

#
# WID COMMANDS
#

cmd_wid_list() {
  if [ -n "$ENV" ]; then
    # Nomad available — query DB directly for full accuracy
    cmd_nomad_exec_sqlite "
SELECT
  a.did,
  COALESCE(a.handle, '?')        AS handle,
  COALESCE(ac.email, '-')        AS email,
  COALESCE(nil.legalId, '-')     AS legalId,
  COALESCE(nil.jid, '-')         AS jid,
  nil.isTestUser,
  nil.linkedAt,
  CASE WHEN cnt.n > 1 THEN 'DUP(' || cnt.n || ')' ELSE '' END AS flags
FROM actor a
LEFT JOIN account ac ON ac.did = a.did
LEFT JOIN neuro_identity_link nil ON nil.did = a.did
LEFT JOIN (
  SELECT did, COUNT(*) AS n FROM neuro_identity_link GROUP BY did
) cnt ON cnt.did = a.did
ORDER BY a.handle, nil.linkedAt;
"
  else
    # No Nomad (plain pds-wadmin with env vars) — use API
    local response
    response=$(api_call "GET" "com.atproto.admin.listNeuroAccounts?limit=1000")
    # Handle both old format (flat legalId/jid scalars) and new format (neuroLinks array)
    echo "$response" | jq -r '
      ["DID", "HANDLE", "EMAIL", "LEGAL_ID", "JID", "LINKED_AT", "FLAGS"],
      (
        .accounts[] |
        . as $acct |
        # Normalize: if neuroLinks array exists use it, else wrap flat scalars
        (if (.neuroLinks | type) == "array" and (.neuroLinks | length) > 0
         then .neuroLinks
         else [{legalId: .legalId, jid: .jid, isTestUser: (.isTestUser // 0), linkedAt: .linkedAt}]
         end) as $links |
        $links[] |
        [
          $acct.did,
          ($acct.handle // "-"),
          ($acct.email // "-"),
          (.legalId // "-"),
          (.jid // .jidRef // "-"),
          (.linkedAt // "-"),
          ([(if .isTestUser == 1 then "TEST" else empty end),
            (if ($acct.duplicateLinks // false) then "DUP" else empty end)] |
           join(",") | if . == "" then "-" else . end)
        ]
      ) | @tsv
    ' | column -t -s $'\t'
  fi
}

cmd_wid_show() {
  local did="$1"

  if [ -z "$did" ]; then
    echo "ERROR: DID is required"
    echo "Usage: $0 wid show <did>"
    exit 1
  fi

  local response
  response=$(api_call "GET" "com.atproto.admin.getNeuroLink?did=$did")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to fetch account details"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  # Normalize: support both old API format (flat scalars) and new (neuroLinks array)
  echo "$response" | jq '
    # Build a normalized neuroLinks array regardless of API version
    (if (.neuroLinks | type) == "array"
     then .neuroLinks
     else [{legalId: .legalId, jid: .jid, jidRef: .jidRef,
             isTestUser: (.isTestUser // 0),
             linkedAt: .linkedAt, lastLoginAt: .lastLoginAt}]
     end) as $links |
    {
      "DID": .did,
      "Handle": .handle,
      "Email": (.email // "N/A"),
      "Duplicate links": (.duplicateLinks // (($links | length) > 1)),
      "Neuro links": [
        $links[] |
        {
          "Legal ID": (.legalId // "—"),
          "JID (test)": (.jid // "—"),
          "JID ref": (.jidRef // "—"),
          "Test user": .isTestUser,
          "Linked at": (.linkedAt // "N/A"),
          "Last login": (.lastLoginAt // "N/A")
        }
      ]
    }
  '
}

cmd_wid_update() {
  local did="$1"
  local new_legal_id="$2"

  if [ -z "$did" ] || [ -z "$new_legal_id" ]; then
    echo "ERROR: Both DID and new Legal ID are required"
    echo "Usage: $0 wid update <did> <legal-id>"
    exit 1
  fi

  if [[ ! "$new_legal_id" =~ @legal\. ]]; then
    echo "ERROR: Invalid Legal ID format (must contain '@legal.')"
    exit 1
  fi

  local data
  data=$(jq -n \
    --arg did "$did" \
    --arg newLegalId "$new_legal_id" \
    '{did: $did, newLegalId: $newLegalId}')

  local response
  response=$(api_call "POST" "com.atproto.admin.updateNeuroLink" "$data")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to update W ID"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Success!"
  echo "$response" | jq '
    {
      "DID": .did,
      "Old W ID": (.oldLegalId // "None"),
      "New W ID": .newLegalId,
      "Updated At": .updatedAt
    }
  '
}

cmd_wid_handle() {
  local did="$1"
  local new_handle="$2"

  if [ -z "$did" ] || [ -z "$new_handle" ]; then
    echo "ERROR: Both DID and new handle are required"
    echo "Usage: $0 wid handle <did> <new-handle>"
    exit 1
  fi

  # Validate handle format (basic check)
  if [[ ! "$new_handle" =~ \. ]]; then
    echo "ERROR: Handle must contain at least one dot (e.g. ingmar.wsocial.eu)"
    exit 1
  fi

  echo "Updating handle for $did"
  echo "  New handle: $new_handle"
  echo ""

  local data
  data=$(jq -n \
    --arg did "$did" \
    --arg handle "$new_handle" \
    '{did: $did, handle: $handle}')

  local response
  response=$(api_call "POST" "com.atproto.admin.updateAccountHandle" "$data")

  # updateAccountHandle returns 200 with empty body on success
  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to update handle"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Handle updated to: $new_handle"
  echo ""
  echo "Next steps:"
  echo "  1. Verify DNS TXT:  dig TXT _atproto.$new_handle +short"
  echo "  2. Verify well-known: curl https://$new_handle/.well-known/atproto-did"
  echo "  3. Verify resolve:  curl '${PDS_HOST}/xrpc/com.atproto.identity.resolveHandle?handle=$new_handle'"
}

#
# TRANSFER COMMANDS
#

cmd_transfer_rehome() {
  local did="$1"
  local target_pds="$2"
  local target_handle="${3:-}"

  if [ -z "$did" ] || [ -z "$target_pds" ]; then
    echo "ERROR: DID and target PDS URL are required"
    echo "Usage: $0 transfer rehome <did> <target-pds-url> [handle]"
    exit 1
  fi

  echo "Rehoming account: $did"
  echo "Target PDS: $target_pds"
  [ -n "$target_handle" ] && echo "New handle: $target_handle"

  local data
  if [ -n "$target_handle" ]; then
    data=$(jq -n \
      --arg did "$did" \
      --arg targetPdsUrl "$target_pds" \
      --arg targetHandle "$target_handle" \
      '{did: $did, targetPdsUrl: $targetPdsUrl, targetHandle: $targetHandle}')
  else
    data=$(jq -n \
      --arg did "$did" \
      --arg targetPdsUrl "$target_pds" \
      '{did: $did, targetPdsUrl: $targetPdsUrl}')
  fi

  local response
  response=$(api_call "POST" "com.atproto.admin.migrateAccount" "$data")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Rehome failed"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Rehome completed!"
  echo "$response" | jq '{
    DID: .did,
    "Source PDS": .sourcePds,
    "Target PDS": .targetPds,
    Status: .status,
    "Rehomed At": .migratedAt
  }'
}

#
# INVITATION COMMANDS
#

cmd_invitation_list() {
  local status="pending"
  local before=""
  local json_output=false
  local limit=50
  local cursor=""

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status=*)
        status="${1#*=}"
        shift
        ;;
      --before=*)
        before="${1#*=}"
        shift
        ;;
      --json)
        json_output=true
        shift
        ;;
      --limit=*)
        limit="${1#*=}"
        shift
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
  done

  local url="io.trustanchor.admin.listInvitations?status=$status&limit=$limit"
  [ -n "$before" ] && url="$url&before=$before"
  [ -n "$cursor" ] && url="$url&cursor=$cursor"

  local response
  response=$(api_call "GET" "$url")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to list invitations"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  if [ "$json_output" = true ]; then
    echo "$response"
  else
    echo "$response" | jq -r '
      ["ID", "EMAIL", "HANDLE", "STATUS", "CREATED", "CONSUMED", "CONSUMING_DID"],
      (
        .invitations[] | [
          .id,
          .email,
          (.preferredHandle // "-"),
          .status,
          .createdAt,
          (.consumedAt // "-"),
          (.consumingDid // "-")
        ]
      ) | @tsv
    ' | column -t -s $'\t'
  fi
}

cmd_invitation_stats() {
  local since=""
  local json_output=false

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --since=*)
        since="${1#*=}"
        shift
        ;;
      --json)
        json_output=true
        shift
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
  done

  local url="io.trustanchor.admin.getInvitationStats"
  [ -n "$since" ] && url="$url?since=$since"

  local response
  response=$(api_call "GET" "$url")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to get stats"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  if [ "$json_output" = true ]; then
    echo "$response"
  else
    echo "Invitation Statistics:"
    echo "===================="
    echo "$response" | jq -r '
      "Pending:      \(.pending)",
      "Consumed:     \(.consumed)",
      "Expired:      \(.expired)",
      "Revoked:      \(.revoked)",
      (if .consumedSince then "Consumed Since: \(.consumedSince)" else empty end),
      (if .conversionRate then "Conversion Rate: \((.conversionRate * 100 | floor))%" else empty end)
    '
  fi
}

cmd_invitation_show() {
  local identifier="$1"

  if [ -z "$identifier" ]; then
    echo "ERROR: Email or ID is required"
    echo "Usage: $0 invitation show <email|id>"
    exit 1
  fi

  # Determine if identifier is numeric (ID) or email
  if [[ "$identifier" =~ ^[0-9]+$ ]]; then
    # It's an ID - fetch by list and filter
    local response
    response=$(api_call "GET" "io.trustanchor.admin.listInvitations?status=all&limit=1000")

    echo "$response" | jq --arg id "$identifier" '
      .invitations[] | select(.id == ($id | tonumber)) | {
        "ID": .id,
        "Email": .email,
        "Preferred Handle": (.preferredHandle // "N/A"),
        "Status": .status,
        "Created At": .createdAt,
        "Expires At": .expiresAt,
        "Consumed At": (.consumedAt // "N/A"),
        "Consuming DID": (.consumingDid // "N/A"),
        "Consuming Handle": (.consumingHandle // "N/A")
      }
    '
  else
    # It's an email - fetch and filter
    local response
    response=$(api_call "GET" "io.trustanchor.admin.listInvitations?status=all&limit=1000")

    echo "$response" | jq --arg email "$identifier" '
      .invitations[] | select(.email == $email) | {
        "ID": .id,
        "Email": .email,
        "Preferred Handle": (.preferredHandle // "N/A"),
        "Status": .status,
        "Created At": .createdAt,
        "Expires At": .expiresAt,
        "Consumed At": (.consumedAt // "N/A"),
        "Consuming DID": (.consumingDid // "N/A"),
        "Consuming Handle": (.consumingHandle // "N/A")
      }
    '
  fi
}

cmd_invitation_create() {
  local email="${1:-}"
  local handle=""

  if [ -z "$email" ]; then
    echo "ERROR: Email is required"
    echo "Usage: $0 invitation create <email> [--handle=HANDLE]"
    exit 1
  fi

  # Parse optional --handle flag
  shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --handle=*)
        handle="${1#*=}"
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
    shift || true
  done

  # Build the UserInvitation event
  local event_data
  local timestamp=$(date +%s)

  if [ -n "$handle" ]; then
    event_data=$(jq -n \
      --arg EventId "UserInvitation" \
      --arg email "$email" \
      --arg handle "$handle" \
      --arg timestamp "$timestamp" \
      '{
        EventId: $EventId,
        Tags: { EMAIL: $email },
        Handle: $handle,
        Timestamp: ($timestamp | tonumber)
      }')
  else
    event_data=$(jq -n \
      --arg EventId "UserInvitation" \
      --arg email "$email" \
      --arg timestamp "$timestamp" \
      '{
        EventId: $EventId,
        Tags: { EMAIL: $email },
        Timestamp: ($timestamp | tonumber)
      }')
  fi

  # Use X-API-Key auth for the neuro provision endpoint
  local response
  response=$(curl -s -X POST "${PDS_HOST}/neuro/provision/account" \
    -H "X-API-Key: ${PDS_ADMIN_PASSWORD}" \
    -H "Content-Type: application/json" \
    -d "$event_data")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to create invitation"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Invitation created successfully"
  echo "Email: $email"
  [ -n "$handle" ] && echo "Suggested handle: $handle"
  if echo "$response" | jq -e '.expiresAt' > /dev/null 2>&1; then
    echo "Expires: $(echo "$response" | jq -r '.expiresAt')"
  fi
}

cmd_invitation_revoke() {
  local identifier="$1"

  if [ -z "$identifier" ]; then
    echo "ERROR: Email or ID is required"
    echo "Usage: $0 invitation revoke <email|id>"
    exit 1
  fi

  local data
  if [[ "$identifier" =~ ^[0-9]+$ ]]; then
    data=$(jq -n --argjson id "$identifier" '{id: $id}')
  else
    data=$(jq -n --arg email "$identifier" '{email: $email}')
  fi

  local response
  response=$(api_call "POST" "io.trustanchor.admin.deleteInvitation" "$data")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to revoke invitation"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Success!"
  if echo "$response" | jq -e '.revoked' > /dev/null 2>&1; then
    echo "Invitation revoked (soft delete)"
  else
    echo "Invitation deleted (hard delete - was not pending)"
  fi
}

cmd_invitation_purge() {
  local status=""
  local before=""

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status=*)
        status="${1#*=}"
        shift
        ;;
      --before=*)
        before="${1#*=}"
        shift
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
  done

  if [ -z "$status" ]; then
    echo "ERROR: --status is required"
    echo "Usage: $0 invitation purge --status=STATUS [--before=TIMESTAMP]"
    echo "Status must be: consumed, expired, or revoked"
    exit 1
  fi

  if [[ ! "$status" =~ ^(consumed|expired|revoked)$ ]]; then
    echo "ERROR: Invalid status. Must be: consumed, expired, or revoked"
    exit 1
  fi

  local data
  if [ -n "$before" ]; then
    data=$(jq -n \
      --arg status "$status" \
      --arg before "$before" \
      '{status: $status, before: $before}')
  else
    data=$(jq -n \
      --arg status "$status" \
      '{status: $status}')
  fi

  echo "Purging $status invitations..."
  [ -n "$before" ] && echo "Before: $before"

  local response
  response=$(api_call "POST" "io.trustanchor.admin.purgeInvitations" "$data")

  if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
    echo "ERROR: Failed to purge invitations"
    echo "$response" | jq -r '.message // .error'
    exit 1
  fi

  echo "✓ Success!"
  echo "$response" | jq -r '"Deleted \(.deletedCount) invitations"'
}

#
# NOMAD COMMANDS
#

cmd_nomad_exec_sqlite() {
  # Internal helper: run a SQL query inside the running Nomad allocation.
  # Uses node + better-sqlite3 (always available in the PDS container).
  # Usage: cmd_nomad_exec_sqlite <sql>
  local sql="$1"

  check_nomad_auth

  local job_name="pds-${ENV}"
  local alloc_id
  alloc_id=$(nomad status -token="${NOMAD_TOKEN}" "$job_name" 2>/dev/null \
    | grep -E "^[a-f0-9]{8}\s+" | grep "running" | head -n1 | awk '{print $1}')

  if [ -z "$alloc_id" ]; then
    echo "ERROR: No running allocation found for job $job_name"
    exit 1
  fi

  # Build a Node.js script that queries the DB via better-sqlite3
  # (sqlite3 CLI is not installed in the PDS container; Node + better-sqlite3 always are).
  # The SQL is written to the script via a temporary env var so no quoting escapes are needed.
  #
  # nomad alloc exec passes the command + args directly — we use "sh -c" so the container
  # shell handles the single exec, and we JSON-encode the SQL into the node script body to
  # avoid any quoting issues crossing the nomad exec boundary.
  local sql_json
  sql_json=$(printf '%s' "$sql" | node -e "
    let s=''; process.stdin.on('data',c=>s+=c); process.stdin.on('end',()=>console.log(JSON.stringify(s)));
  ")

  local node_script
  node_script="
const path=require('path'),fs=require('fs');
const sql=${sql_json};
const appRoot='/app';

// Resolve better-sqlite3: handles both npm flat layout and pnpm virtual store
let DB;
const directPath=path.join(appRoot,'node_modules','better-sqlite3');
if(fs.existsSync(path.join(directPath,'package.json'))){
  DB=require(directPath);
} else {
  // pnpm virtual store: /app/node_modules/.pnpm/better-sqlite3-X.Y.Z.../node_modules/better-sqlite3
  try {
    const pnpmStore=path.join(appRoot,'node_modules','.pnpm');
    const ent=fs.readdirSync(pnpmStore).find(e=>e.startsWith('better-sqlite3'));
    if(ent) DB=require(path.join(pnpmStore,ent,'node_modules','better-sqlite3'));
  } catch(e) {}
}
if(!DB){
  // Last resort: require.resolve with search paths
  for(const base of [appRoot, process.cwd()]){
    try { DB=require(require.resolve('better-sqlite3',{paths:[base]})); break; } catch(e) {}
  }
}
if(!DB){ console.error('ERROR: better-sqlite3 not found in container'); process.exit(1); }

let dbPath;
const d=process.env.PDS_DATA_DIRECTORY;
if(d){dbPath=path.join(d,'account.sqlite');}
else{for(const p of['/data/account.sqlite','/var/run/account.sqlite','/var/run/pds/account.sqlite']){if(fs.existsSync(p)){dbPath=p;break;}}}
if(!dbPath||!fs.existsSync(dbPath)){console.error('ERROR: account.sqlite not found');process.exit(1);}
const db=new DB(dbPath,{readonly:true});
const rows=db.prepare(sql).all();
db.close();
if(rows.length===0){console.log('(no rows)');process.exit(0);}
const cols=Object.keys(rows[0]);
const widths=cols.map(c=>Math.max(c.length,...rows.map(r=>String(r[c]??'').length)));
const fmt=r=>cols.map((c,i)=>String(r[c]??'').padEnd(widths[i])).join('  ');
console.log(cols.map((c,i)=>c.padEnd(widths[i])).join('  '));
console.log(widths.map(w=>'-'.repeat(w)).join('  '));
rows.forEach(r=>console.log(fmt(r)));
"

  # Pass the script as argv[1] of node -e  ("-e SCRIPT" is a single nomad-exec argument,
  # no shell involved, so no further quoting needed on the nomad side)
  nomad alloc exec -token="${NOMAD_TOKEN}" -task pds "$alloc_id" \
    node -e "$node_script"
}

cmd_wid_db() {
  local custom_query=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --query=*)
        custom_query="${1#*=}"
        shift
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
  done

  if [ -z "$ENV" ] || [ "$ENV" = "wadmin" ]; then
    echo "ERROR: wid db requires environment context (use pds-wadmin-dev, pds-wadmin-stage, or pds-wadmin-prod)"
    exit 1
  fi

  if [ -n "$custom_query" ]; then
    cmd_nomad_exec_sqlite "$custom_query"
    return
  fi

  # Default: full neuro_identity_link dump with duplicate annotation.
  # jidRef is omitted here because migration 014 may not yet be deployed;
  # use --query= to include it once the column exists.
  cmd_nomad_exec_sqlite "
SELECT
  nil.did,
  COALESCE(a.handle, '?') AS handle,
  nil.legalId,
  nil.jid,
  nil.isTestUser,
  nil.linkedAt,
  nil.lastLoginAt,
  CASE WHEN cnt.n > 1 THEN '*** DUP (' || cnt.n || ')' ELSE '' END AS dup_flag
FROM neuro_identity_link nil
LEFT JOIN actor a ON a.did = nil.did
JOIN (
  SELECT did, COUNT(*) AS n FROM neuro_identity_link GROUP BY did
) cnt ON cnt.did = nil.did
ORDER BY nil.did, nil.linkedAt;
"
}

cmd_nomad_status() {
  check_nomad_auth

  local job_name="pds-${ENV}"
  echo "Checking status for job: $job_name"
  echo ""

  nomad status -token="${NOMAD_TOKEN}" "$job_name"
}

cmd_nomad_logs() {
  local tail_lines=""
  local follow=false

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --tail=*)
        tail_lines="${1#*=}"
        shift
        ;;
      --follow|-f)
        follow=true
        shift
        ;;
      *)
        echo "ERROR: Unknown option: $1"
        exit 1
        ;;
    esac
  done

  export NOMAD_ADDR="https://nomad.wsocial.cloud"
  check_nomad_auth

  local job_name="pds-${ENV}"
  echo "Fetching logs for job: $job_name"

  # Get the running allocation ID
  local alloc_id
  alloc_id=$(nomad status -token="${NOMAD_TOKEN}" "$job_name" | grep -E "^[a-f0-9]{8}\s+" | grep "running" | head -n1 | awk '{print $1}')

  if [ -z "$alloc_id" ]; then
    echo "ERROR: No running allocation found for job $job_name"
    exit 1
  fi

  echo "Using allocation: $alloc_id"
  echo ""

  # Build log command
  local log_cmd="nomad alloc logs -token=\"${NOMAD_TOKEN}\""
  [ -n "$tail_lines" ] && log_cmd="$log_cmd -tail -n $tail_lines"
  [ "$follow" = true ] && log_cmd="$log_cmd -f"
  log_cmd="$log_cmd $alloc_id pds"

  # Execute
  eval "$log_cmd"
}

#
# GOAT COMMANDS
#

cmd_goat() {
  # Check if goat is available
  if ! command -v goat >/dev/null 2>&1; then
    echo "ERROR: 'goat' command not found in PATH"
    echo "Please install goat or ensure it is in your PATH"
    exit 1
  fi

  # Pass all arguments to goat
  # PDS_HOST and PDS_ADMIN_PASSWORD are already set by check_env()
  exec goat "$@"
}

#
# MAIN
#

main() {
  if [ $# -eq 0 ]; then
    usage
  fi

  check_env

  local category="$1"
  shift

  case "$category" in
    wid)
      if [ $# -eq 0 ]; then
        echo "ERROR: WID command required"
        usage
      fi
      local cmd="$1"
      shift
      case "$cmd" in
        list)
          cmd_wid_list
          ;;
        show)
          cmd_wid_show "$@"
          ;;
        update)
          cmd_wid_update "$@"
          ;;
        handle)
          cmd_wid_handle "$@"
          ;;
        db)
          cmd_wid_db "$@"
          ;;
        *)
          echo "ERROR: Unknown wid command: $cmd"
          usage
          ;;
      esac
      ;;

    transfer)
      if [ $# -eq 0 ]; then
        echo "ERROR: Transfer command required"
        usage
      fi
      local cmd="$1"
      shift
      case "$cmd" in
        rehome)
          cmd_transfer_rehome "$@"
          ;;
        *)
          echo "ERROR: Unknown transfer command: $cmd"
          usage
          ;;
      esac
      ;;

    invitation)
      if [ $# -eq 0 ]; then
        echo "ERROR: Invitation command required"
        usage
      fi
      local cmd="$1"
      shift
      case "$cmd" in
        create)
          cmd_invitation_create "$@"
          ;;
        list)
          cmd_invitation_list "$@"
          ;;
        stats)
          cmd_invitation_stats "$@"
          ;;
        show)
          cmd_invitation_show "$@"
          ;;
        revoke)
          cmd_invitation_revoke "$@"
          ;;
        purge)
          cmd_invitation_purge "$@"
          ;;
        *)
          echo "ERROR: Unknown invitation command: $cmd"
          usage
          ;;
      esac
      ;;

    nomad)
      if [ $# -eq 0 ]; then
        echo "ERROR: Nomad command required"
        usage
      fi
      local cmd="$1"
      shift
      case "$cmd" in
        status)
          cmd_nomad_status "$@"
          ;;
        logs)
          cmd_nomad_logs "$@"
          ;;
        *)
          echo "ERROR: Unknown nomad command: $cmd"
          usage
          ;;
      esac
      ;;

    goat)
      # Pass all remaining arguments to goat
      cmd_goat "$@"
      ;;

    help|--help|-h)
      usage
      ;;

    *)
      echo "ERROR: Unknown category: $category"
      usage
      ;;
  esac
}

main "$@"
